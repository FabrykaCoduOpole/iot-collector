ğŸ”§ Implementation Steps
Setup local development environment
Create microservices (MQTT service, API Gateway)
Add monitoring with Prometheus/Grafana
Containerize applications
Setup Kubernetes manifests
Create Terraform infrastructure
Implement CI/CD pipeline
Deploy to AWS EKS



run mqtt-service
--------------------------------
# Start the services
docker-compose up -d

# Check if services are running
docker-compose ps

# View logs
docker-compose logs -f

test mqtt-service
---------------------------------
# Publish a test message
mqtt pub -t 'sensors/device1/data' -h 'localhost' -m '{"deviceId":"device1","temperature":25.5,"humidity":60}'
# Check the logs to see if the message was received
docker-compose logs mqtt-service

# Connect to the PostgreSQL database
docker-compose exec postgres psql -U postgres -d iot_data

# Inside PostgreSQL, query the data
SELECT * FROM sensor_data;


-----------------------------------

# Zatrzymaj kontenery
docker-compose down

# UsuÅ„ wolumen PostgreSQL, aby wymusiÄ‡ ponowne utworzenie bazy danych
docker volume rm zeatask_postgres_data

# Uruchom kontenery
docker-compose up -d

-----------------------------------

# PoÅ‚Ä…cz siÄ™ z bazÄ… danych PostgreSQL
docker-compose exec postgres psql -U postgres -d iot_data

# W konsoli PostgreSQL wykonaj zapytanie
\dt


CREATE TABLE IF NOT EXISTS sensor_data (
  id SERIAL PRIMARY KEY,
  device_id VARCHAR(50) NOT NULL,
  topic VARCHAR(100) NOT NULL,
  data JSONB NOT NULL,
  timestamp TIMESTAMP NOT NULL
);

CREATE INDEX idx_sensor_data_device_id ON sensor_data(device_id);
CREATE INDEX idx_sensor_data_timestamp ON sensor_data(timestamp);


------------------------------------

# WyÅ›lij testowÄ… wiadomoÅ›Ä‡ MQTT
mqtt pub -t 'sensors/device1/data' -h 'localhost' -m '{"deviceId":"device1","temperature":25.5,"humidity":60}'

# SprawdÅº logi MQTT Service
docker-compose logs mqtt-service

# PoÅ‚Ä…cz siÄ™ z bazÄ… danych PostgreSQL
docker-compose exec postgres psql -U postgres -d iot_data

# W konsoli PostgreSQL wykonaj zapytanie
SELECT * FROM sensor_data;


------------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        IoT Data Collector System                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  IoT Devices â†’ MQTT Broker â†’ API Gateway â†’ Microservices       â”‚
â”‚                     â†“                           â†“               â”‚
â”‚               Message Queue              Database Layer          â”‚
â”‚                     â†“                           â†“               â”‚
â”‚            Monitoring & Observability    Data Processing        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


| Component              | Local Version         | AWS Cloud Equivalent |
| ---------------------- | --------------------- | -------------------- |
| MQTT Broker            | Mosquitto (Docker)    | AWS IoT Core         |
| REST API Backend       | Node.js / Python / Go | Same container       |
| Database               | PostgreSQL / MongoDB (Docker)   | AWS RDS / DynamoDB   |
| Monitoring             | Prometheus + Grafana  | Prometheus + Grafana |
| Kubernetes             | minikube / kind       | AWS EKS              |
| Infrastructure as Code | -                     | Terraform or AWS CDK |
| CI/CD                  | Gi


------------------------------------------------------------------------
IAC

The VPC module we've created will provide:

A VPC with DNS support enabled
2 public subnets (for load balancers and public-facing resources)
2 private subnets (for EKS nodes and application components)
2 database subnets (for RDS PostgreSQL)
An Internet Gateway for public internet access
A NAT Gateway for private subnets to access the internet
Appropriate route tables and associations



------------------------------------------------------------------------
In the next steps, we'll add modules for:
EKS (Kubernetes cluster)
RDS (PostgreSQL database)
IoT Core (MQTT broker)
ECR (Container repositories)
Monitoring with Prometheus and Grafana


-----------------------------------------------------------------------------

AWS infrastructure for your IoT Data Collector system. In this step, we have:

Created the EKS module to establish the Kubernetes cluster
Set up IAM roles and policies for the EKS cluster and node group
Configured security groups for the EKS cluster and nodes
Updated the main configuration to include the EKS module
Added outputs for the EKS cluster
The EKS module we've created will provide:

An EKS cluster running Kubernetes version 1.28
A node group with 2 t3.medium instances (scalable from 1 to 5)
IAM roles and policies for the EKS cluster and node group
Security groups for the EKS cluster and nodes
Both private and public endpoint access for the EKS API server




DB_USERNAME: postgres
DB_PASSWORD: your-secure-password
RDS_ENDPOINT: iot-collector-dev-db.cq2loiugs1cc.us-east-1.rds.amazonaws.com
DB_NAME: iot_data

kubectl exec -it postgres-client -- /bin/bash
psql "postgres://postgres:your-secure-password@iot-collector-dev-db.cq2loiugs1cc.us-east-1.rds.amazonaws.com:5432/iot_data"
